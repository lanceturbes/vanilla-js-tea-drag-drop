<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Element Factory</title>
    <script type="module" defer>
      function swapItems(itemList, indexA, indexB) {
        const items = itemList.slice();
        const itemB = items[indexB];
        items[indexB] = items[indexA];
        items[indexA] = itemB;
        return items;
      }

      function h(type, attributes, children) {
        return { type, attributes, children };
      }

      function createElement({ type, attributes, children }) {
        const el = document.createElement(type);

        for (const attr in attributes) {
          const value = attributes[attr];

          if (attr.startsWith("on") && typeof value === "function") {
            el.addEventListener(attr.slice(2), value);
          } else {
            el.setAttribute(attr, value);
          }
        }

        for (const child of children) {
          if (typeof child === "string") {
            el.appendChild(document.createTextNode(child));
          } else {
            el.appendChild(createElement(child));
          }
        }

        return el;
      }

      function render(element, node) {
        node.replaceChildren(element);
      }

      // "state" object to keep track of things that should not cause re-renders
      const data = {
        draggedIndex: null,
      };

      function init() {
        return {
          count: 0,
          itemList: [
            { id: 0, name: "Apple" },
            { id: 1, name: "Banana" },
            { id: 2, name: "Cherry" },
          ],
        };
      }

      function update(msg, model) {
        switch (msg.type) {
          case "INCREMENT":
            return { ...model, count: model.count + 1 };
          case "DRAG_END":
            return msg.payload === null || msg.payload === undefined
              ? model
              : {
                  ...model,
                  itemList: swapItems(
                    model.itemList,
                    data.draggedIndex,
                    msg.payload
                  ),
                };
          default:
            return model;
        }
      }

      function view(model, dispatch) {
        return h("div", null, [
          h(
            "button",
            {
              onclick: () => {
                dispatch({ type: "INCREMENT" });
              },
            },
            [`Count: ${model.count}`]
          ),
          h(
            "ul",
            null,
            model.itemList.map((item, i) =>
              h(
                "li",
                {
                  draggable: "true",
                  id: `item-${item.id}`,
                  ondragstart: (event) => {
                    data.draggedIndex = i;
                  },
                  ondrop: (event) => {
                    event.preventDefault();
                    dispatch({ type: "DRAG_END", payload: i });
                  },
                  ondragenter: (event) => {
                    event.preventDefault();
                  },
                  ondragover: (event) => {
                    event.preventDefault();
                    event.dataTransfer.effectAllowed = "move";
                  },
                },
                [item.name]
              )
            )
          ),
        ]);
      }

      function main(options, node) {
        const { init, update, view } = options;
        let model = init();

        function dispatch(msg) {
          model = update(msg, model);
          const nextView = view(model, dispatch);
          render(createElement(nextView), node);
        }

        const initialView = view(model, dispatch);
        render(createElement(initialView), node);
      }

      const rootNode = document.getElementById("root");
      main({ init, update, view }, rootNode);
    </script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
